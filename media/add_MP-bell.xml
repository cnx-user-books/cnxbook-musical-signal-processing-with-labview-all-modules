<!--title = {mini-project} Risset Bell Synthesis
-->

<?xml version='1.0' standalone='yes' ?>
<LVData>
<Version>8.2</Version>

<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Objective</Val> </String>

<String> <Name>para</Name> <Val>
Additive synthesis builds up complex sounds from simple sounds (sinusoids). Additive synthesis implies more than just doing Fourier series, though: each sinusoidal component is assigned its own frequency and amplitude trajectory (resulting in a partial), so complex, time-varying sounds can be generated by summing these partials together.</Val> </String>

<String> <Name>para</Name> <Val>
In this project you will use additive synthesis to emulate the sound of a bell using a technique described by Jean-Claude Risset, an early pioneer in {term}computer music{/term}.		
</Val> </String>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Prerequisite Modules</Val> </String>

<String> <Name>para</Name> <Val>
If you have not done so already, please study the pre-requisite modules 
{cnxn document=&quot;m????&quot;}Additive Synthesis Concepts{/cnxn} and
{cnxn document=&quot;m????&quot;}Additive Synthesis Techniques{/cnxn}.
If you are relatively new to LabVIEW, consider taking the course {cnxn document=&quot;col10440&quot;}LabVIEW Techniques for Audio Signal Processing{/cnxn}  which provides all of the foundation you need in order to complete this mini-project activity, including working with arrays, creating subVIs, playing an array to the soundcard, and saving an array as a .wav sound file.
</Val> </String>

<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Deliverables</Val> </String>

<Cluster> <Name>list</Name> <NumElts>3</NumElts>
<EW>
<Name>type</Name>
<Choice>Bulleted</Choice>
<Choice>Enumerated</Choice>
<Val>0</Val>
</EW>
<String> <Name>list name (optional)</Name> <Val></Val> </String>
<Array> <Name>list items</Name> <Dimsize>4</Dimsize>
<String> <Name>String</Name> <Val>All LabVIEW code that you develop (block diagrams and front panels)</Val> </String>
<String> <Name>String</Name> <Val>All generated sounds in .wav format</Val> </String>
<String> <Name>String</Name> <Val>Any plots or diagrams requested</Val> </String>
<String> <Name>String</Name> <Val>Summary write-up of your results</Val> </String>
</Array>
</Cluster>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Description of the Risset Bell</Val> </String>

<String> <Name>para</Name> <Val>
Jean-Claude Risset&apos;s book {cite}Introductory Catalogue of Computer-Synthesized Sounds (Bell Telephone Laboratories, 1969){/cite} includes an additive synthesis method for a bell-like sound. After analyzing the ringing characteristics of physical bells, he determined that a bell-like tone could be created by using non-harmonic partials whose decay times are approximately inversely proportional to frequency. In addition, pairs of low-frequency partials with a slight frequency offset create a &quot;beating&quot; effect.		
</Val> </String>

<String> <Name>para</Name> <Val>
The partials for the Risset bell are available in this CSV-type spreadsheet: {link src=&quot;risset_bell.csv&quot;}risset_bell.csv{/link}. The columns are:
</Val> </String>

<Cluster>
<Name>list</Name>
<NumElts>3</NumElts>
<EW>
<Name>type</Name>
<Choice>Bulleted</Choice>
<Choice>Enumerated</Choice>
<Val>1</Val>
</EW>
<String>
<Name>list name (optional)</Name>
<Val></Val>
</String>
<Array>
<Name>list items</Name>
<Dimsize>5</Dimsize>
<String> <Name>String</Name> <Val>partial number</Val> </String>
<String> <Name>String</Name> <Val>intensity in dB</Val> </String>
<String> <Name>String</Name> <Val>duration multiplier (indicates fraction of overall duration)</Val> </String>
<String> <Name>String</Name> <Val>frequency multiplier (indicates interval ratio from base frequency)</Val> </String>
<String> <Name>String</Name> <Val>frequency offset (in Hz)</Val> </String>
</Array>
</Cluster>

<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Part 1: Attack/Decay Envelope Generator</Val> </String>

<String> <Name>para</Name> <Val>
Create an attack/decay intensity envelope composed of two straight-line segments as shown in {cnxn target=&quot;fig-ADenv&quot;/}:</Val> </String>

<Cluster> <Name>image</Name> <NumElts>3</NumElts> 
<String> <Name>ID (optional)</Name> <Val>fig-ADenv</Val> </String>
<String> <Name>name</Name> <Val>ADenv</Val> </String>
<String> <Name>caption</Name> <Val>Attack/decay envelope specification</Val> </String>
</Cluster>

<String> <Name>para</Name> <Val>
		The value &quot;-60 dB&quot; corresponds to an amplitude of 0.001, effectively silence. The total duration of the envelope should be based on a 
		front-panel control called &quot;duration [s]&quot; (its unit is seconds), and another control called &quot;attack [ms]&quot; 
		(its unit is milliseconds).

Convert the intensity envelope into an amplitude envelope by &quot;undoing&quot; the equation for decibels.
</Val></String>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Part 2: Multiple Envelopes</Val> </String>

<String> <Name>para</Name> <Val>
Enclose your envelope generator in a for-loop structure which takes values from {link src=&quot;risset_bell.csv&quot;}risset_bell.csv{/link}. Connect a control to the count terminal so that you can adjust how many envelopes to view.

Use &quot;auto indexing&quot; on the for-loop to create an array of envelopes, then view the array as graph (you will see all of the envelopes superimposed on the same graph, with each envelope a different color). Confirm that your envelopes have the correct amplitudes and durations.

Plot both the intensity envelopes and amplitude envelopes for all partials, and include these plots with your deliverables.
</Val> </String>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Part 3: Sinusoidal Tone Generator</Val> </String>

<String> <Name>para</Name> <Val>
Add a sinusoidal tone generator to your main loop. The base frequency should be set by a front-panel control called &quot;freq [Hz]&quot;, and the frequency multiplier and offset for each partial should be used to set the actual frequency. Also include a front-panel control to select the system sampling frequency &quot;fs [Hz]&quot;.

Apply the amplitude envelope, and then add the partial to the sound that was generated on the previous pass of the loop. Regardless of whether you use a shift register or a feedback node, you will need to initialize the audio signal with an array of zeros which is of the same length as your envelopes.

Remember to use the &quot;QuickScale&quot; built-in subVI on the finished audio waveform to ensure that all of its values lie in the range +/- 1.
</Val> </String>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
<String> <Name>sec</Name> <Val>Part 4: Experiment with Parameters</Val> </String>

<String> <Name>para</Name> <Val>
Your front panel controls should include the following adjustable parameters: number of partials, total duration, base frequency, sampling frequency, and attack time. Listen to the audio and view the spectrogram as you adjust the parameters.

To get started, listen to the sound with the first partial only, and then with the first two partials, and so on until you hear all eleven partials. Building up the sound from silence by adding more and more partials is the essence of &quot;additive synthesis.&quot;

Try varying the attack time. What is the maximum attack time that still sounds like the striking of a bell?

Try adjusting the total duration and base frequency. Remember to adjust the sampling frequency high enough so that you do not produce aliasing. If the sampling frequency is too high, however, all of the partials will be &quot;crammed&quot; into the bottom of the spectrogram plot.

Overall, what values produce a realistic-sounding bell? 

Create .wav files for three distinct sets of parameters, and discuss the motivation for your choices. Include a spectrogram plot for each of the three bell sounds.
</Val> </String>


<String> <Name>secend</Name> <Val></Val> </String>
<!-------------------------------------------------------->
</LVData>
